/*
# Архитектура создания торговой стратегии

Архитектура создания торговой стратегии, наследующей класс `SystemBase`, включает несколько ключевых компонентов и этапов. Давайте рассмотрим их подробнее.

## Наследование от SystemBase

Класс `SystemBase` является базовым классом для всех торговых систем. Он предоставляет основные методы и свойства, необходимые для реализации торговой логики. При создании новой стратегии необходимо создать класс, который наследует `SystemBase`, и реализовать его методы.

## Определение условий торговли

В классе, наследующем `SystemBase`, необходимо определить условия для открытия и закрытия позиций. Это делается с помощью переопределения следующих свойств:

- **IsLongEnter**: Условие для входа в длинную позицию.
- **IsLongExit**: Условие для выхода из длинной позиции.
- **IsShortEnter**: Условие для входа в короткую позицию.
- **IsShortExit**: Условие для выхода из короткой позиции.

Эти условия могут основываться на различных индикаторах, таких как MACD, RSI и других.

## Настройка параметров

В классе стратегии можно определить параметры, которые будут использоваться для настройки индикаторов и других аспектов стратегии. Эти параметры могут быть заданы с помощью атрибутов, таких как `[HandlerParameter]`, что позволяет пользователю настраивать их через интерфейс.

## Метод Execute

Метод `Execute` является основным методом, который выполняет логику стратегии. В этом методе:

- Инициализируются переменные и параметры.
- Рассчитываются значения индикаторов на основе исторических данных.
- Вызывается метод `Run`, который запускает цикл обработки баров.

## Метод Run

Метод `Run` в `SystemBase` выполняет основную логику торговли. Он:

- Вызывает метод `Setup`, который возвращает начальные параметры.
- Запускает цикл, который проходит по всем барам, начиная с указанного.
- Для каждого бара выполняет торговые операции и рисует сигналы на графике.

## Метод Setup

Каждая стратегия должна реализовать метод `Setup`, который возвращает объект `Setup`. Этот объект содержит информацию о базовом таймфрейме и минимальных ограничениях на номера баров для начала торговли (будет выбрано максимальное из этих минимальных).

## Рисование на графике

Метод `Draw` позволяет визуализировать данные на графике. В этом методе можно использовать различные методы рисования, предоставляемые интерфейсом `IPaint`, для отображения индикаторов, сигналов и других данных.

## Использование индикаторов

Стратегия может использовать различные технические индикаторы, такие как MACD и RSI, которые реализованы в классе `Indicators`. Эти индикаторы могут быть вызваны в методе `Execute` для получения значений, необходимых для принятия торговых решений.

## Обработка позиций

Класс `SystemBase` предоставляет методы и свойства для работы с текущими позициями, такие как `InLongPosition`, `InShortPosition`, а также информацию о текущих позициях через интерфейс `IPositionInfo`.

## Свойство Now

Свойство `Now` в базовом классе `SystemBase` играет ключевую роль в управлении текущим состоянием торговой системы. Вот основные моменты, объясняющие его назначение:

1. **Индексация баров**: Свойство `Now` указывает текущий индекс бара, для которого рассчитываются свойства и выполняются торговые операции. Это позволяет системе отслеживать, на каком баре она находится в данный момент, и принимать решения на основе данных именно этого бара.

2. **Цикл обработки**: В методе `Run` происходит итерация по всем барам, начиная с заданного индекса. Значение `Now` обновляется в каждой итерации, что позволяет системе последовательно обрабатывать данные и выполнять торговые сигналы для каждого бара.

3. **Расчет индикаторов**: Многие индикаторы и условия для открытия или закрытия позиций зависят от текущего бара. Например, в коде ниже условие для выхода из длинной позиции использует `Now` для доступа к значению RSI на текущем баре: `_rsi[Now] > 70`.
*/


using MegaTrade.Basic;
using MegaTrade.Basic.Extensions;
using MegaTrade.Indicators;
using TSLab.Script;
using TSLab.Script.Handlers;
using TSLab.Script.Handlers.Options;

//Пример реализации торговых сигналов
[HandlerName("Моментум двух таймфреймов")] // Название стратегии
[InputsCount(2)] // Количество формальных параметров, которое ожидается в методе Execute
[Input(0, TemplateTypes.SECURITY, Name = "Источник")]
[Input(1, TemplateTypes.SECURITY, Name = "Сжатый таймфрейм")]
[OutputsCount(0)] // Говорит TSLab, что из Execute возвращается 0 значений, то есть void
public class TradingSignalsExample : SystemBase
{
    public override bool IsLongEnter => _macd[Now - 1] <= 0 && _macd[Now] > 0 /* Пример условия для входа в длинную позицию */;
    public override bool IsLongExit => _rsi[Now] > 70 /* Пример условия для выхода из длинной позиции */;
    public override bool IsShortEnter => true || false /* Условия для входа в короткую позицию */;
    public override bool IsShortExit => true || false /* Условия для выхода из короткой позиции */;

    public void Execute(ISecurity basicTimeframe, ISecurity compressedTimeframe)
    {
        // Инициализация переменных и расчет индикаторов
        _basicTimeframe = basicTimeframe;

        // Это лучше вытащить в локальную переменную, чтобы не обращаться многократно к тому свойсту, а то оно долго выполняется
        IList<double>? closePrices = compressedTimeframe.ClosePrices;

        _rsi = closePrices.RSI(RsiPeriod)
            //Все данные должны разжиматься данным методом с передачей в него того ISecurity из которого они получены
            .DecompressFrom(compressedTimeframe);

        _macd = closePrices.MACD(SmallMacd, BigMacd).DecompressFrom(compressedTimeframe);

        Run();
    }

    protected override Setup Setup() => new()
    {
        BasicTimeframe = _basicTimeframe /* Укажите базовый таймфрейм */,
        MinBarNumberLimits = [RsiPeriod] /* Укажите минимальные ограничения для баров */
    };

    private ISecurity _basicTimeframe = null!;
    private IList<double> _rsi = [];
    private IList<double> _macd = [];

    // Визуализация данных на графике
    protected override void Draw() => Paint
        .Chart("MACD").Function(_macd, "MACD")
        .Chart("RSI").Function(_rsi, "RSI");

    //Так задаются параметры торговой стратегии, которые приходят из TSLab
    [HelperDescription("Период RSI")]
    [HandlerParameter(Name = "Период RSI", Default = "20", Min = "1", Max = "100", Step = "1")]
    public int RsiPeriod { get; set; }

    [HelperDescription("Малый период MACD")]
    [HandlerParameter(Name = "SmallMacd", Default = "12", Min = "2", Step = "1")]
    public int SmallMacd { get; set; }

    [HelperDescription("Больший период MACD")]
    [HandlerParameter(Name = "BigMacd", Default = "26", Min = "3", Step = "1")]
    public int BigMacd { get; set; }
}

/*
## Установка объемов для входа и выхода в торговой стратегии
      
При разработке торговой стратегии, наследующей класс `SystemBase`, можно установить объемы для входа и выхода из позиций. Объём измеряется в штуках, а не в лотах, которые из этих штук состоят. Если свойства не переопределить - будет торговать одним лотом.
   
В классе, наследующем `SystemBase`, можно переопределить следующие свойства для установки объемов:
   
- `LongEnterVolume`: Определяет объем для открытия длинной позиции.
- `LongExitVolume`: Определяет объем для закрытия длинной позиции.
- `ShortEnterVolume`: Определяет объем для открытия короткой позиции.
- `ShortExitVolume`: Определяет объем для закрытия короткой позиции.

Эти свойства могут возвращать фиксированные значения или вычисляться на основе текущих условий, таких как размер счета, риск на сделку и другие факторы.
Если позиция уже открыта и происходит повторый вход, то просто докупит в случае лонга, либо допродаст в случае шорта
Если позиция закрывается с объёмом меньше, чем в позиции, то позиция закроется частично.
 */

//Рассмотрим, как это можно сделать, а также как реализовать частичные входы и выходы.
public class VolumesExample : SystemBase
{
    // Пример установки фиксированного объема
    public override double LongEnterVolume => 100; // Открытие 100 штук в длинной позиции
    public override double LongExitVolume => 100; // Закрытие 100 штук в длинной позиции
    public override double ShortEnterVolume => 100; // Открытие 100 штук в короткой позиции
    public override double ShortExitVolume => 100; // Закрытие 100 штук в короткой позиции
    // Или можно использовать динамическое вычисление объема

    protected override Setup Setup() => throw new NotImplementedException();
}

/*
## Установка тейк-профита и стоп-лосса
   
Установка тейк-профита и стоп-лосса является важной частью управления рисками в торговых стратегиях. В классе, наследующем `SystemBase`, можно переопределить свойства, отвечающие за установку этих уровней.
   
В классе стратегии можно переопределить следующие свойства для установки тейк-профита и стоп-лосса:
  
- **LongTakeProfit**: Устанавливает уровень тейк-профита для длинной позиции.
- **LongStopLoss**: Устанавливает уровень стоп-лосса для длинной позиции.
- **ShortTakeProfit**: Устанавливает уровень тейк-профита для короткой позиции.
- **ShortStopLoss**: Устанавливает уровень стоп-лосса для короткой позиции.
   
Эти свойства могут возвращать фиксированные значения, вычисляться на основе текущих рыночных условий или задаваться в процентах от цены входа. Если позиция не открыта, значения этих уровней просто игнорируются.

LongPosition и ShortPosition всегда будут возвращать значение, которое можно безопасно использовать. Даже если позиция ещё не открывалась, они всё-равно будут возвращать значение (null object pattern)
*/
public class StopsExample : SystemBase
{
    // Установка тейк-профита для длинной позиции
    public override double? LongTakeProfit => LongPosition.EntryPrice * 1.015; // 1.5% выше

    // Установка стоп-лосса для длинной позиции
    public override double? LongStopLoss => LongPosition.EntryPrice * 0.99; // 1% ниже

    // Установка тейк-профита для короткой позиции
    public override double? ShortTakeProfit => ShortPosition.EntryPrice * 0.985; // 1.5% ниже

    // Установка стоп-лосса для короткой позиции
    public override double? ShortStopLoss => ShortPosition.EntryPrice * 1.01; // 1% выше

    protected override Setup Setup() => throw new NotImplementedException();
}